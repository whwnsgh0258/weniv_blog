# CS_Java

## 1. Java의 특징

1. 자바는 객체지향 프로그래밍을 대표하는 언어 입니다.
2. 기본 자료형을 제외한 모든 요소들이 객체로 표현되고 객체지향 개념의 특징인 캡슐화, 상속, 다형성이 적용 됩니다.
3. 한번 작성한 코드가 JVM(Java Virtual Machine)을 통해 OS와 관계없이 독립적으로 실행 됩니다.
4. Garbage Collection(GC)을 통해 불필요한 메모리를 자동으로 해제하기 때문에 개발자가 직접 명시적으로 메모리를 해제할 필요가 없습니다. (메모리 누수 방지,
   성능 향상)

## 2. JVM

### 2.1 JVM의 역할

1. JVM은 자바 프로그램을 실행할 때 플롯폼에 의존하지 않는 환경을 제공합니다.
2. 가비지 컬렉션을 통해 자동으로 메모리를 관리해줍니다.

### 2.2 JVM의 구성요소

1. Class Loader
    - 바이트 코드(.class)를 JVM 메모리에 로드하는 역할을 합니다.
2. Runtime Data(메모리 구조)
    - Method Area: 클래스 로드시 필요한 메타데이터, 상수, 정적 변수, 메서드 코드 등을 저장 합니다.
    - Heap Area: 객체와 배열이 저장되는 영역으로, Garbage Collector(GC)가 관리하는 메모리 입니다.
    - Stack Area: 각 스레드의 실행과 흐름을 관리하는 영역으로, 메서드 호출마다 생성되는 Stack Frame을 통해 지역변수, 메서드 호출 정보 등을 저장합니다.
    - PC Register: 현재 실행중인 명령어의 주소를 저장 합니다.
    - Native Method Stack: Java 코드가 아닌 다른 언어로 작성된 네이티브 코드를 실행하기 위해 사용됩니다.
3. Execution Engine(실행엔진)
    - 인터프리터: 바이트 코드를 한줄 씩 읽고 실행 합니다.
    - JIT 컴파일러: 성능을 높이기 위해 반복적으로 사용되는 코드를 네이티브 코드로 변환하여 캐싱 합니다.(한번 컴파일 된 코드는 이후 인터프린팅 없이 실행 됩니다.)
    - Garbage Collector: 사용하지 않는 객체를 자동으로 헤재하여 메모리 누수를 방지합니다.

### 2.3 JVM의 동작과정

1. 자바 컴파일러가 소스파일(.java)을 바이트코드(.class)로 컴파일 합니다.
2. JVM의 Class Loader가 컴파일 된 바이트코드를 메모리에 적재 합니다.
3. 실행 엔진이 로드된 바이트 코드를 해석하고 실행하며, JIT 컴파일러가 최적화된 네이티브 코드로 변환하여 속도를 높입니다.
4. 실행 중 생성된 객체는 힙 영역에 저장되고, GC가 주기적으로 필요없는 객체를 정리합니다.

## 3. Java에서 제공하는 원시타입과 바이트

1. 정수형: byte, short, int, long (1바이트, 2바이트, 4바이트, 8바이트)
2. 실수형: float, double (4바이트, 8바이트)
3. 문자형: char (2바이트)
4. 논리형: boolean (1바이트)

## 4. 오버라이딩(Overriding)과 오버로딩(Overloading)의 차이

- 오버라이딩은 상위 클래스에 있는 메서드를 하위 클래스에서 재정의 하는것 입니다.
- 오버로딩은 객체지향 프로그래밍의 특징 중 다형성의 예시 중 하나로 매개변수나 타입을 다르게하여 같은 이름의 메서드를 여러개 정의하는것 입니다.

## 5. 추상클래스와 인터페이스의 차이

### 5.1 추상클래스

- 클래스 내부에 추상 메서드가 하나이상 포함 되어있거나, abstract로 정의된 클래스 입니다.
- 공통 로직을 추상화 시키고 상속을 통해 기능을 확장하는 방식으로 사용됩니다.
- 비즈니스 로직이 들어갈 수 있습니다.
- 다중 상속이 불가능 합니다.

### 5.2 인터페이스

- 모든 메서드가 추상 메서드로 이루어진 클래스 입니다.
- 인터페이스를 구현하는 구현체에 대해 특정 메서드가 반드시 존재해야 합니다.
- 상속이 아닌 추상화된 메서드를 구현한다는 개념이기 때문에 여러개의 인터페이스를 구현할 수 있습니다.

## 6. 싱글톤 패턴이란?

- 하나의 인스턴스를 생성하여 사용하는 디자인 패턴
- 인스턴스가 1개만 존재해야 한다는 것을 보장하고 싶은 경우 또는, 동일한 인스턴스를 자주 생성해야 할 때 사용합니다.(메모리 낭비 방지)